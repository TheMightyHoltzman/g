<?php

/**
 * Created by PhpStorm.
 * User: heiko
 * Date: 31.07.17
 * Time: 15:00
 *
 * @input  int     the length of the sample to be generated
 * @output string  a sample of the stream
 *
 * Validates the input, then generates a sample
 *
 */

if (sizeof($argv) !== 2) {
    echo "ERROR: Invalid parameter nr - only one parameter (sample-size) is allowed" . PHP_EOL;
    return;
} elseif (!filter_var($argv[1], FILTER_VALIDATE_INT)) {
    echo "ERROR: Supplied sample size must be of type int" . PHP_EOL;
    return;
}

$sampleSize = (int)$argv[1];
$sampler = new StreamSampler($sampleSize);
$sampler->work();

/**
 * Produces a frequency-map of the characters of the input-stream and then generates a sample by using these
 * frequencies as possibilities of occurence
 *
 * Note:
 *       1.)
 *       I used this approach, because, in your example, the order of the characters did not seem to matter
 *       (EMETN is not a subsequence of THEQUICKBROWNFOXJUMPSOVERTHELAZYDOG - the chars do not appear in that order)
 *       - otherwise I would have taken the first few characters of the given length and then added and disposed of characters
 *       with a certain probability
 *
 *       2.) there were 3 different kinds of input, and i did not understand how all of them should be used without giving
 *           additional parametes to the StreamSampler without telling it about the source,
 *           however, all of the inputs can be produced through piping:
 *          a.) Values piped directly: by definition
 *          b.) Values generated by a random-source within the language:
 *            see the noise-function in the StreamSampler
 *          c.) Values from an API:
 *              curl -sb -H "Accept: application/json" "https://www.random.org/strings/?num=1000&len=8&digits=on&upperalpha=on&loweralpha=on&unique=on&format=plain&rnd=new"
 *
 *        3.)
 *       the StreamSampler, as of now, might run into problems, if the nr of occurences of a character exceeds the max-value of a php-int -
 *       PHP_MAX_INT - hence in the worst-case-scenario a file with a single character repeated (PHP_MAX_INT + 1) - times would cause it to fail:
 *       however, this file could still be "very large": a normal utf-8 character needs 1-4 bytes, (I assume 1 byte in this calculation):
 *       1 byte * 9,223,372,036,854,775,807 > 9 Exabytes (which I assume is quite big)
 */
class StreamSampler
{
    /**
     * nr of chars to sample
     */
    private $sampleSize;

    /**
     * nr of chars already sampled
     */
    private $sampled;

    /**
     * key-value pairs of chars and their respective occurences
     */
    private $charMap;

    /**
     * StreamSampler constructor.
     * @param $sampleSize
     */
    public function __construct($sampleSize)
    {
        $this->sampleSize = $sampleSize;
        $this->sampled = 0;
        $this->charMap = [];
    }

    /**
     * Reads lines from a stream and generates a random sample
     */
    public function work()
    {
        while ($line = fgets(STDIN)) {
            $this->processLine($line);
        }
        $sampleString = $this->generateSample();
        echo "Random Sample: $sampleString" . PHP_EOL;
    }

    /**
     * @param string $line
     *
     * Processes a single line from a stream, increments the character map accordingly
     */
    private function processLine($line)
    {
        $lineLength = strlen($line);
        for ($i = 0; $i < $lineLength; $i++) {
            $currentChar = $line[$i];
            if (!array_key_exists($currentChar, $this->charMap)) {
                $this->charMap[$currentChar] = 0;
            }
            $this->charMap[$currentChar]++;
            $this->sampled++;
        }
    }

    /**
     * Generates a sample string based on the char-frequencies
     * @return string
     */
    private function generateSample()
    {
        $this->transformCharMap();
        $sampleWord = "";
        for ($i = 0; $i < $this->sampleSize; $i++) {
            $sampleWord .= $this->generateChar();
        }
        return $sampleWord;
    }

    /**
     * Transforms the charMap into a map of chars -> cumulative frequencies
     */
    private function transformCharMap()
    {
        $sum = 0;
        foreach ($this->charMap as $char => $nrOccurences) {
            $sum += $nrOccurences;
            $this->charMap[$char] = $sum;
        }
    }

    /**
     * Picks a char at random according to the cumulative frequencies - charMap needs to be transformed before
     * @return string
     */
    private function generateChar()
    {
        $rand = mt_rand(0, $this->sampled - 1);
        $leftThreshold = 0;
        foreach ($this->charMap as $char => $rightThreshold) {
            if ($leftThreshold <= $rand && $rand < $rightThreshold) {
                return $char;
            }
            $leftThreshold = $rightThreshold;
        }
    }

    /**
     * Generates random-noise
     *
     * @param $length
     */
    private function noise($length)
    {
        $rand = "";
        $characters = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
        $i = 0;
        while ($i < $length) {
            $rand .= $characters[rand(0, strlen($characters) - 1)];
            $i++;
        }
        echo $rand;
    }
}

?>
